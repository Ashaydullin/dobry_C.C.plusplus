# 2.5 Функция scanf() для форматированного ввода

Функция `scanf()` выполняет форматированное чтение данных из стандартного входного потока `stdin`. Эта функция имеет следующее определение(прототип):

<p align="center"> int scanf(const char* format, …); </p>

Здесь первый параметр `format` - это указательн на форматную строку, на подобии той что рассматривалась в функции `printf()`. Последующее троеточие указывает на произвольное число дополнительных параметров, как правило, переменных. Функция возвращает целое значение типа `int`, **равное числу прочитанных элементов из входного потока** `stdin`.

Для функции `scanf()` также как и для `printf()` предусмотрены спецификаторы, но они немного другие:

|Спецификатор |Описание                                                                                        |
|-------------|------------------------------------------------------------------------------------------------|
|%d           | Целое число со знаком в десятичной  форме. (Приводится к типу `int`).                          |
|%i           | Целое число в десятичной, шестнадцатеричной и восьмеричной системах. (Приводится к типу `int`).|
|%u           | Целое беззнаковое (unsigned) число в десятичной форме. (Приводится к типу `unsigned int`).     |
|%o           | Целое число в восмьеричной форме. (Приводится к типу `int`).                                   |
|%x %X        | Целое число в шестнадцатеричной форме. (Приводится к типу `int`).                              |
|%f, %e, %g, <br> %F, %E, %G | Вещественное число. (Приводится к типу `float`).                                     |
|%c           | Символ в соответствии с текущей кодовой таблицей. (Приводится к типу `char`).                  |
|%s  | Строка(последовательность символов). Читается до первого пробела, перевода строки или символа табуляции.|

Самый простой вариант использования функции `scanf()` соответствует чтению отдельных символов из входного потока. Для этого используется спецификатор `%c` следующим образом:

```
#include <stdio.h>
 
int main(void)
{
    char byte;
 
    int count = scanf("%c", &byte);
    printf("count = %d, byte = %c\n", count, byte);
 
    return 0;
}
```

Это работает посредством того что если в форматной строке записан спецификатор `%c`, то функция `scanf()` читает один байт из буфера входного потока `stdin`. Предположим, там находятся числа 100 и 53. Значит функция читает первое значение 100. Далее необходимо этот байт данных скопировать в переменную `byte`. Для копирования байта данных в переменную из входного потока `stdin` достаточно в соответствующую ячейку памяти скопировать прочитанные данные, так как любая переменная это непрерывная последовательность байт а в нашем примере это одна ячейка так как переменная `byte` имеет тип данных `char`. Именно поэтому функции `scanf()` передается не значение переменной(как это было в функции `printf()`), а адрес переменной. Зная этот адрес, функция `scanf()` имеет возможность менять значение переменной `byte` записывая определенные данные напрямую в указанную ячейку памяти. Так происходит передача данных из входного потока в указанные переменные с помощью функции `scanf()`.

**Оператор** `&` **перед именем переменной возвращает адрес этой переменной.** 

**Если данные были успешно прочитаны функция** `scanf()` **вернет значение 1 это говорит о том что в одну переменную были успешно занесены данные из входного потока** `stdin`.

Для примера запишем подряд два вызова функции `scanf()`:


```
#include <stdio.h>
 
int main(void)
{
    char byte1 = '0', byte2 = '0';
 
    int res1 = scanf("%c", &byte1);
    int res2 = scanf("%c", &byte2);
 
    printf("byte1 = %c, byte2 = %c\n", byte1, byte2);
    
    return 0;
}
```

Если при запуске введем сразу два символа, например `cd`, то во входном буфере окажутся оба символа и второй вызов функции `scanf()` прочитает оставшееся значение не требуя ввода с клавиатуры. После запуска программы нас ожидает следующий результат:

<p align="center"> byte1 = c, byte2 = d </p>

**Всегда следует помнить о входном буфере и если в нем имеется какая-нибудь информация, то следующий вызов функции** `scanf()` **будет читать эти данные, не ожидая ввода с клавиатуры новых данных.**

Два вызова можно объеденить в один, вот так:

```
int res = scanf("%c%c", &byte1, &byte2);
printf("res = %d: byte1 = %c, byte2 = %c\n", res, byte1, byte2);
```

После ввода тех же символов увидим следующую строку:

<p align="center"> res = 2: byte1 = c, byte2 = d </p>

переменная `res` принимает значение `2`, так как данные были успешно записаны в две переменные: `byte1` и `byte2`. **Перед каждой переменной базового типа не забываем прописывать оператор амперсанд.**

Теперь поставим символ пробела между спецификаторами в форматной строке:

```
int res = scanf("%c %c", &byte1, &byte2);
```

Этот пробел означает любые пробельные символы, которые могут присутствовать между двумя порциями данных. К пробельным символам относят: **пробел**, **перевод строки**, **табуляцию**. Это символ может и вовсе отсутствовать, мы можем ввести данные с клавиатуры следующими способами:

<p align="center"> cd; c d; c    d; c\nd; c\td </p>

Во всех вариантах будут прочитаны два символа `cd` и занесены в переменные `byte1` и `byte2`. Таким образом форматная строка `%c %c` указывает прочитать первый символ из входного буфера(любой символ), затем пропустить все пробельные символы и прочитать следующий не пробельный.

Теперь вместо пробела поставим запятую:

```
int res = scanf("%c,%c", &byte1, &byte2);
```

При таком формате будет ожидаться любой первый символ а затем обязательно должна идти запятая, потом еще один любой символ. Например:

<p align="center"> c,d </p>

А если входные данные не соответсвуют формату то есть cd то функция `scanf()` успешно прочитает только первый символ а следующий оставит во входном потоке, так как вместо запятой символ буквы `d`. В этом случае переменная `res` будет равна 1 а в переменной `byte2` останется прежнее значение.

Мы можем комбинировать разные символы разделителей в форматной строке:

```
int res = scanf("%c, %c", &byte1, &byte2);
```

В таком случае будет читаться первый символ, затем должна идти запятая, после возможные пробельные символы и только потом следующий не пробельный символ. Вот варианты ввода данных для данного примера:

<p align="center"> c,d; c, d; c,\nd, c,\td и т.п. </p>

### Чтение числовых значений из входного потока stdin

Если данные представлены в виде целых десятичных чисел со знаком, то для этого часто используют спецификатор `%d`. Этот спецификатор приводит целые числа к типу `int`. Это важный момент и вот почему запишем программу следующим образом:

```
#include <stdio.h>
 
int main(void)
{
    long long var_lli = 0;
 
    int res = scanf("%d", &var_lli);
    printf("res = %d: var_lli = %lld\n", res, var_lli);
 
    return 0;
}
```

На входе функция `scanf()` ожидает целое число со знаком, умещающееся в тип `int`. Если ввести с клавиатуры значение:

<p align="center"> 1234567890 </p>

то на выходе будет строка:

<p align="center"> res = 1: var_lli = 1234567890 </p>

Все было прочитано успешно. Но если увеличить значение до:

<p align="center"> 12345678901234 </p>

то значение сначало будет приведено к типу `int` а только потом записано в переменную `var_lli` типа `long long`. Поэтому на выходе будет неккоректное значение:

<p align="center"> res = 1: var_lli = 1942892530 </p>

Вот почему важно правильно сочетать спецификаторы преобразований с типами переменных.

Для указания в форматной строке функции `scanf()` разных типов входных данных применяются следующие модификаторы, перечисленные в таблице:


|Модификатор                 |Описание                                                                 |
|----------------------------|-------------------------------------------------------------------------|
|<p align="center"> h </p>   |`%hd`, `%hi`, - для short; <br> `%hx`, `%ho`, `%hu` - для unsigned short |
|<p align="center"> hh </p>  |`%hhd` - для signed char; <br> `%hhu` - для unsigned char                |
|<p align="center"> l </p>   |`%ld`, `%li` - для long int; <br> `%lx`, `%lo`, `%lu` - для unsigned long; <br> `%lf`, `%lg`, `%le` - для double |
|<p align="center"> L </p> |`%Lf`, `%Lg`, `%Le` - для long double                                      |
|<p align="center"> ll (в стандарте C99) </p>| `%lld` - для long long int; <br> `%llu` - для unsigned long long |
|<p align="center"> цифры </p> | Максимальная ширина ввода (либо достигается максимальная ширина, либо служебный символ).|
|<p align="center"> * </p> | Пропуск данных.                                                           |

К примеру если нам нужно прочитать очень длинное число и сохранить его в типе `long long` нам необходимо использовать в функции `scanf()` модификатор `%lld`:

```
int res = scanf("%lld", &var_lli);
```

Теперь, при вводе длинного числа 12345678901234 мы его и увидим в выходной строке:

<p align="center"> res = 1: var_lli = 12345678901234 </p>

И так со всеми остальными типами данных. Стоит обратить внимание что спецификаторы `%f`, `%e`, `%g` выполняют преобразование только к типу `float` а не `double` как это делает функция `printf()`. Если в функции `scanf()` используется переменная типа `double`, то для нее следует применять модификаторы `%lf`, `%le`, `%lg`. Например:

```
#include <stdio.h>
 
int main(void)
{
    long long var_lli = 0;
    double var_d = 0;
 
    int res = scanf("%lld %lf", &var_lli, &var_d);
    printf("res = %d: var_lli = %lld, var_d = %.2f\n", res, var_lli, var_d);
 
    return 0;
}
```

В этом случае ожидается ввод сначала целого числа а затем вещественного, которое будет приведено к типу `double`. В частностни, при вводе значений:

<p align="center"> 123 56.54 </p>

Получаем на выходе строку:

<p align="center"> res = 2: var_lli = 123, var_d = 56.54 </p>

А вот если функция `scanf()` будет указан модификатор для типа `float`:

```
int res = scanf("%lld %f", &var_lli, &var_d);
```

то после ввода тех же значений получим строку:

<p align="center"> res = 2: var_lli = 123, var_d = 0.00 </p>

Переменаня `res` по прежнему принимает значение 2 потому что формально входные данные соответствовали форматной строке, но копирование данных `float` в переменную типа `double` не дало ожидаемого результата. И все из-за неверного спецификатора `%f`.

Другие же подобные модификаторы работают аналогичным образом. Интересной особенностью обладает модификатор `*`, который позволяет пропускать вводимые данные. Например мы знаем что на входе ожидаются данные в формате:

|<p align="center"> id </p>                 |<p align="center"> price </p>    |<p align="center"> weight </p>|
|-------------------------------------------|---------------------------------|----------------------------------------|
|<p align="center">целое число без знака</p>|<p align="center">целое число</p>|<p align="center">вещественное число</p>|


Нас интересуют только center и weight. Будем полагать что числа записаны через разделитель точка с запятой. Это частый формат `csv` файла. Для считывая только двух значений center и weight форматную строку в функции `scanf()` можно записать следующим образом:

```
#include <stdio.h>
 
int main(void)
{
    unsigned int price = 0;
    double weight = 0.0;
 
    int res = scanf("%*llu; %u; %lf", &price, &weight);
    printf("res = %d: price = %d, weight = %.2f\n", res, price, weight);
 
    return 0;
}
```

Введем с клавиатуры данные:

<p align="center"> 10; 1000; 54.65 </p>

на выходе получим строку:

<p align="center"> es = 2: price = 1000, weight = 54.65 </p>

Функция `scanf()` возвратило значение 2 и переменные price, weigth принимают правильные значения (последние два). Первое значение 10 было прочитано, но проигнорировано. Конечно, оно при этом должно соответствовать спецификатору `%llu`, то есть быть десятичным. Если к примеру указать вещественное значение:

<p align="center"> 10.34; 1000; 54.65 </p>

то это ошибка формата и последующие два числа прочитаны не будут:

<p align="center"> res = 0: price = 0, weight = 0.00 </p>

Вот так и работает функция `scanf()` которая позволяет читать данные из буфера стандартного потока `stdin` данные в указаном формате. При этом считывание останавливается либо после получения данных, либо при ошибке формата ввода. Следует помнить что **ошибочные данные остаются во входном буфере**.

[ссылка на оригинальную прозу](https://proproprogs.ru/c_base/c_funkciya-scanf-dlya-formatirovannogo-vvoda)


