# 2.2 Присваивание, числовые и символьные литералы, sizeof

На этом занятии, более подробно рассмотрим оператор присваивания. На предыдущем занятии мы научились объявлять переменные. Например так:

```
#include <stdio.h>
 
int main(void)
{
    int var;
    return 0;
}
```

Создается целочисленная переменная `var` внутри функции `main()`. Так как мы еще не присваивали ей никакого значения, то она будет содержать произвольные данные. Следующей строчкой занесем значение `100` в целочисленное хранилище `var`. 

Сделать это можно с помощью операции присваивания, которая в языке С опеределена символовм равно `=`:

```
var = 100;
```

Стоит обратить внимание на то что речь идет именно об операции а не об операторе. В языке С присваивание реализовано как **выражение** и помимо копирования данных эта операция еще возвращает скопированное значение. В данном случае - это число 100. И только благодаря точки с запятой, записанной в конце, компилятор понимает, где заканчивается данная конструкция и начинается следующая. То есть, точка с запятой превращает операцию присваивания в оператор - завершенную конструкцию языка С.

Операция присваивания копирует значение из правого оперенда в левый операнд. Соответственно левый операнд должен явно или косвенно определять ячейки памяти, куда можно занести значение указанное в правой части. Как говорят в программировании, слева должно стоять **модифицируемое лево-допустимое выражение** (l-value). В простейшем случае - это просто имя переменной. Могут быть и другие конструкции с которыми предстоит познакомиться в будущем.

Учитывая, что присваивание это операция, можно записать ее и в таком виде:

```
int var, size;
size = var = 100;
```

Во первых в программе через запятую объявляются две целочисленные переменные типа `int`. Так тоже можно делать и это вполне распространненая практика, объявление сразу нескольких переменных одного и того же типа. В следующей строчке сразу двум переменным присваивается целочисленное значение `100`. Такая запись допустима благодаря тому факту что присваивание это операция а не законченным оператором. Вначале число `100` будет присвоено переменной `var` затем возвращенное значение `100` присваивается переменной `size`. Точка с запятой в конце завершает эту конструкцию и определяет ее как оператор.

Можно было записать эту программу и так:

```
int var, size;
var = 100;
size = 100;
```

Современные компиляторы в обоих случая сформируют оптимальный машинный код и корректно переведут эту программу в набор машинных инструкций. Поэтому какой вариант присваивания выбирать - решает сам программист.

Правило хорошего тона предполагает что все важные переменные следует объявлять вначале каждого блока операторов(то есть фигурных скобок). А уже затем проводить операции над ними. Именно так и сделано в нашей программе, сначала идет объявление переменных через запятую, затем действия над ними. Такой подход приводит к удобочитаемости кода программы и ее отладки. Любые другие временные переменные, можно объявлять в любом месте программы, чтобы визуально она не засорялась лишними деталями.

### Инициализация переменных

В языке С как и во многих других языках высокого уровня, можно определять значение переменных в момент ее объявления, делается это например вот так:

```
int total = 1024;
```

Визуально это выглядит как обычное присваивание переменной значения. Но в данном случае происходит именно **инициализация** переменной, то есть ее объявление. Так же следует понимать что инициализация и присваивания это совершенно разные операции в контексте программирования на языке С. На уровне машинных кодов эти операции также могут быть реализованны по разному. То есть:

* механизм инициализации запускается когда мы во время объявления переменной (любого типа) сразу же присваиваем ей некоторое значение.
* обычное присваивание подразумевает под собой внесение некоторого значения уже объявленной переменной.

Пример когда мы комбинируем обычное объявление и присваивание для еще большего понимания:

```
int total = 1024, buffer;
```

Синтаксически так тоже можно делать в своих программах.

### Целочисленные и символьные литералы

Теперь внимательнее рассмотрим число 100 в нашей программе и зададимся вопросом. Как оно воспринимается компилятором и где хранится? В программе явно прописанные числовые значения называются **числовыми литералами** и представляются как целочисленная константа типа `int`. Так сделано потому что так решил создатель языка С Деннис Ритчи: все целочисленные константы, записанные в программе в **десятичном виде**, хранить на уровне типа `int`. Но только в том случае если число умещается в диапазон этого типа. В современных 32/64-битных компьютерах тип `int` как правило составляет 4 байта (32 бита) и описывает диапазон значений:

<p align="center"> [-2147483648; 2147483647] </p>

Если целочисленный литерал положителен и не умещается в этот диапазон, то компилятор подбирает соответствующий размер типов данных в порядке возрастания:

<p align="center"> int, unsigned int, long, unsigned long, long long, unsigned long long </p>

В случае если недостаточно и самого большого (что сложно себе представить в реальных задачах) компилятор выдаст ошибку.

**Но так только с целыми числами записанными в десятичном виде.** Язык С позволяет определять в программе числовые литералы еще и шестнадцатеричной и восьмеричной форме. Делается это просто, например:

```
int dec, hex, oct;
dec = 100;
hex = 0x1FA;
oct = 0123;
```

Здесь:

* 100 - это десятичная форма записи;
* 0x1FA(число 1FA) - это шестнадцатеричная форма записи;
* 0123 - это восьмеричная форма записи;

Для записи шестнадцатеричных чисел перед числом ставится префикс `0x`, для записи восьмеричных чисел ставится `0`. Так можно описывать любые числа в нужном формате. Естественно на уровне машинных кодов они представлены единым образом в виде набора бит и запись числовых литералов в той или иной форме служит лишь для удобочитаеомсти.

Но с шестнадцатеричными и восьмеричными литералами есть один важный нюанс. Их компилятор изначально не представляет типом `int`, как десятичные а типом **unsigned int**. Соответственно, если литерал не умещается в этот тип, то берутся больших размеров в порядке:

<p align="center"> unsigned int, unsigned long, unsigned long long </p>

При желании возможно явно указать **компилятору** тип числового литерала. Для этого используютя следующие суффиксы:

* `U` и `u` - использование модификатора unsigned в определении литерала;
* `L` и `l` - использование типа `long` при определении литерала;
* `LL` и `ll` - использование типа `long long` при определении литерала;

Обычно в программе прописывают большие буквы `L` так как маленькие легко можно спутать с изображением числа 1. Суффикс `U` можно записывать и отдельно, но можно комбинировать суффиксами `L` и `LL`:

```
int dec_i, dec_ui, dec_l, dec_ul;
dec_i = 100;        // тип литерала int
dec_ui = 100U;      // тип литерала unsigned int
dec_l = 100L;       // тип литерала long
dec_ul = 100UL;     // тип литерала unsigned long
```

Как же литералы сохраняются непосредственно в программе? Компилятор переводит их в машинный код и хранит непосредственно в скомпилированной программе как неизменяемые данные, то есть как константы. Когда программа загружается в память компьютера, то вместе с ней загружаются все данные, которые мы явно определяем в тексте.

Теперь посмотрим на тип `char`, который формально определен как символьный или целочисленный. Как такое может быть? Все очень просто. Объявим переменную этого типа например:

```
char ch;
```

а затем присвоим ей символьное значение `'d'`:

```
ch = 'd';
```

стоит обратить внимание как прописан символ в тексте программы: он заключен в одинарные кавычки (апострофы). И только так можно определять символьные литералы в языке С. Когда компилятор видит одинарные кавычки, он сразу же распознает информацию внутри них как символ. Никакие другие кавычки для этого использовать нельзя. К примеру двойные зарезервированны для объявления строк поэтому запись:

```
ch = "d";
```

приведет к ошибке на этапе компиляции. Если же совсем убрать кавычки, то символ `d` будет восприниматься как переменная.

```
ch = d;
```

Поэтому следует запомнить что для определения символов в тексте программы используются только одинарные кавычки `''`.

На уровне программы мы научились отдельно прописывать символы. Но как они будут представлятся в машинных кодах? Там могут быть только числа и это очень важный момент. Все символьные литералы в программе переводятся в соответсвующие коды. Как к примеру в вводной части курса были представлены фрагменты таблицы ASCII, компилятор может использовать ее для кодирование символов в машинный код(но не обязательно ASCII). В нашем случае символ `d` имеет код `100`. Любой другой символ будет иметь другой код. И по сути, строка программы:

```
ch = 'd';
```

в нашем конкретном случае может быть заменена на:

```
ch = 100;
```

Хотя явно так прописывать не следует, потому что в другой кодовой таблице код символа `d` может быть другим.

Далее, мы можем вывести это значение переменной `ch` с помощью функции `printf()` в двух форматах: символьном и числовом.

```
printf("ch = %c, code = %d\n", ch, ch);
```

Об этой функции более подробно будет рассказно в дальнейшем, но пока следует отметить что вместо символов `%с` будет подставлено значение `ch`, но выведено в виде целого десятичного числа.

После запуска программы увидим:

```
ch = d, code = 100
```

Этот факт показывает что компьютеру важно лишь какое число хранится в переменной `ch`, а его интерпретация может быть самой разной: или как символ или как целое число. Стоит обратить внимание, как компилятор преобразовывает символьные литералы в числа типа `int`, а не `char`, как можно было бы ожидать. Это, как раз связано с тем, что он воспринимает любой символ как десятичное число, а оно по умолчанию представляется типом `int`. 

При работе с символами мы формально можем использовать любой другой целочисленный тип. Например, прописать так:

```
int ch;
ch = 'd';
```

В данном случае на работу программы это никак не повлияет. Но все же если планируется хранение кодов символов, то лучше использовать тип `char` в целях экономии памяти этого типа достаточно для представления всех основных символов включая и русские буквы.

### Вещественные литералы

Помимо целочисленных в программе можно прописать и вещественные литералы. Определять их можно следующими способами:

```
double d1, d2, d3, d4;
d1 = 10.0;
d2 = -7.;
d3 = 1e2;
d4 = 5e-3;
```

В первых двух случаях используестя символ точки. Обратим внимание, несмотря на то что числа 10.0 и -7.0 с математической точки зрения соответствуют целыми числам 10 и -7, на уровне программы они будут вещественными и иметь тип `double`, так как все вещественные типы данных компилятор языка С представляет именно этим типом. Соответственно, математические операции с числами 10.0 и -7.0 будут выполняться несколько иначе, чем с аналогичными целыми числами. Это следует иметь в виду.

Последние два варианта - запись числа в экспоненциальной форме:

<p align="center"> <число>e<степень десятки> </p>

Например запись:

<p align="center"> 1e2 = 1 * 10^2 = 100 </p>
<p align="center"> 5e-3 = 5 * 10^-3 = 100 </p>

В любом случае  экспоненциальная форма переводится в вещественное число типа `double`, даже если математически оно является целым а не дробным.

При желании, мы можем явно указать компилятору переводить вещественный литерал в тип `float` добавив суффикс `f`:

```
d1 = 10.0f;
```

в такой записи вещественное число 10.0 будет представляться типом `float`, а не `double`. Это бывает полезно, когда используется переменная типа `float` и ей правильно было бы присвоить значение того же типа:

```
float var_f;
var_f = 10.0f;
```

Тогда компилятор не выдаст предупреждение (warning) о возможной потере данных в момент присваивания значения переменной `var_f`.

### Операция sizeof

Довольно распространенная операция языка С. Она возвращает число байт занимаемых в памяти переменной или, отведенных под тип данных. Синтаксис следующий:

<p align="center"> sizeof(<тип | имя переменной>); </p>
<p align="center"> sizeof <имя переменной>; </p>

Во втором случае мы можем записать ключевое слово `sizeof` без круглых скобок, но тогда эта операция применяется только к переменным, но не к типам. Чтобы не запоминать эти тонкости, обычно `sizeof` записывают с круглыми скобками и указывают либо тип данных, либо имя переменных. Например:

```
int size_float = sizeof(float);
int size_var_f = sizeof(var_f);
```

на выходе получаем число байт, которое занимает тип `float` и переменная `var_f`. Соответственно:

```
int size_ch = sizeof(char);
```

все равно единице.

[ссылка на оригинальную прозу](https://proproprogs.ru/c_base/c_operaciya-prisvaivaniya-chislovye-i-simvolnye-literaly-operaciya-sizeof)
